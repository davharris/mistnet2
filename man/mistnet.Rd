% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mistnet.R
\name{mistnet}
\alias{mistnet}
\title{Build and fit a neural network with random effects}
\usage{
mistnet(x, y, n_z, activators, n_hidden, error_distribution, priors,
  fit = TRUE, starttests = FALSE, ...)
}
\arguments{
\item{x}{A numeric matrix of predictor variables}

\item{y}{A numeric or integer matrix of response variables}

\item{n_z, }{The number of latent random variables to include as predictors
alongside x}

\item{activators}{A list of \code{\link{activator}} objects, one per
network layer}

\item{n_hidden}{An integer vector determining the number of hidden nodes in
each hidden layer. Its length should be one less than that of the
\code{activators} list.}

\item{error_distribution}{An \code{\link{error_distribution}} object}

\item{priors}{[[Add me]]}

\item{fit}{Logical. Should the model be fitted or should an untrained model
be returned. Defaults to TRUE}

\item{starttests}{Should \code{\link[optimx]{optimx}}'s \code{starttests} be
run? Can be useful for identifying errors but is not usually needed.}

\item{...}{Additional arguments to \code{\link{mistnet_fit}}}
}
\value{
A \code{network} object
}
\description{
Build and fit a neural network with random effects
}
\examples{
set.seed(1)

# Load data from the `vegan` package
data(mite, mite.env, package = "vegan")

# x is a matrix of environmental predictors
x = scale(model.matrix(~., data = mite.env)[, -1])

# y is a matrix of abundances (counts) for 35 species of mites
y = as.matrix(mite)

# Fit a neural network with one hidden layer of 10 nodes and an elu
# activation function. The response variable has a Poisson distribution
# with a log link (exp_activator). The prior distributions for each layer
# are each standard normal distributions, and two latent variables are used.
net = mistnet(
   x = x,
   y = y,
   n_z = 2,
   n_hidden = 10,
   activators = list(elu_activator, exp_activator),
   priors = list(
     make_gamlss_distribution("NO", mu = 0, sigma = 1),
     make_gamlss_distribution("NO", mu = 0, sigma = 1)
   ),
   error_distribution = make_gamlss_distribution("PO")
)

print(net)

# show the model's predictions for each layer
str(feedforward(net, par = unlist(net$par_skeleton)))

# Calculate the log-likelihood for each observation under the fitted model
log_density(net, par = unlist(net$par_skeleton), include_penalties = FALSE)

# Include penalty terms from the prior to calculate the log-posterior instead
log_density(net, par = unlist(net$par_skeleton), include_penalties = TRUE)
}

